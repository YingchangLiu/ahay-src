from rsf.proj import *
import math
import os, sys

# This SConstruct script is provided with the manuscript entitled "An Overview of Reproducible 3D Seismic Data Processing and Imaging Using Madagascar" published in Geophysics 83, 2 (2018), pp. F9-F20 by Can Oren and Robert L. Nowack. This script was tested on the stable version 1.7 of Madagascar.

                       ############################
                       ####    Data Loading    ####
                       ############################

# Download the raw shot gathers.
Fetch('fetch/npr3_field.sgy','teapot',server='http://s3.amazonaws.com',top='')

# Read and convert the shot gathers from segy to rsf format.
Flow(['fetch/npr3_field.rsf','fetch/npr3_field_hdr.rsf',
      'fetch/npr3_field.thdr','fetch/npr3_field.bhdr'],
     'fetch/npr3_field.sgy',
     '''
     sfsegyread tfile=${TARGETS[1]} 
     hfile=${TARGETS[2]}  bfile=${TARGETS[3]} 
     ''')

# Create some CMP gathers that can be used for headers in later flows.
# Traces are never used, so just make tmax very small.
Flow(['fetch/npr3_field_cmp.rsf','fetch/npr3_field_cmp_hdr.rsf'],
     ['fetch/npr3_field.rsf','fetch/npr3_field_hdr.rsf'],
     '''
     sftahsort verbose=1 input=${SOURCES[0]} sort='iline xline offset'
     | sftahwindow tmax=.008 
     | sftahwrite
       verbose=1
       mode=seq
       output=${TARGETS[0]}
       outheaders=${TARGETS[1]}
     ''',stdout=0,stdin=0)

                       ############################
                       ######    Geometry    ######
                       ############################

# All shot coordinates.
Flow('geom/sx','fetch/npr3_field_hdr.rsf','dd type=float | headermath output="sx"')
Flow('geom/sy','fetch/npr3_field_hdr.rsf','dd type=float | headermath output="sy"')
Flow('geom/sxsycoord',['geom/sx','geom/sy'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# All receiver coordinates.
Flow('geom/gx','fetch/npr3_field_hdr.rsf','dd type=float | headermath output="gx"')
Flow('geom/gy','fetch/npr3_field_hdr.rsf','dd type=float | headermath output="gy"')
Flow('geom/gxgycoord',['geom/gx','geom/gy'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# Plot all the shot and receiver coordinates.
Plot('geom/sxsycoord',
    '''
    sfwindow j2=40 |
    graph symbol="+" title="(a)" label1="X" unit1="ft" label2="Y" unit2="ft" 
    plotcol=5 labelsz=11 labelfat=3 titlefat=3 titlesz=11
    ''')

Plot('geom/gxgycoord',
    '''
    sfwindow j2=30 |
    graph symbol="+" title="(b)" label1="X" unit1="ft" label2="Y" unit2="ft"
    plotcol=6 labelsz=11 labelfat=3 titlefat=3 titlesz=11
    ''')

# Collect all shot and receiver coordinates in one plot.
Result('geom/sxsygxgycoord','geom/sxsycoord geom/gxgycoord','SideBySideAniso')

# Read and write one shot gather.
Flow(['geom/fldr214.rsf','geom/fldr214_hdr.rsf'],
       ['fetch/npr3_field.rsf','fetch/npr3_field_hdr.rsf'],
       '''
         sftahsort 
         input=$SOURCE
         sort="fldr:214,214"
         verbose=1
       | sftahwindow ns=2047
       | sftahwrite
          verbose=1
          mode=seq
          output=$TARGET
       ''',stdout=0,stdin=0)

# One shot coordinate.
Flow('geom/sx1','geom/fldr214_hdr.rsf','dd type=float | headermath output="sx"')
Flow('geom/sy1','geom/fldr214_hdr.rsf','dd type=float | headermath output="sy"')
Flow('geom/sxsycoord1',['geom/sx1','geom/sy1'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# Receiver coordinates associated with the single shot.
Flow('geom/gx1','geom/fldr214_hdr.rsf','dd type=float | headermath output="gx"')
Flow('geom/gy1','geom/fldr214_hdr.rsf','dd type=float | headermath output="gy"')
Flow('geom/gxgycoord1',['geom/gx1','geom/gy1'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# Plot one shot coordinate and its corresponding receiver coordinates.
Plot('geom/sxsycoord1',
    '''
    graph symbol="+" title="(a)" label1="X" unit1="ft" label2="Y" unit2="ft" plotcol=5 plotfat=12 labelsz=11 symbolsz=8
    min1=7.87573e+05 max1=8.09806e+05 min2=9.3841e+05 max2=9.76868e+05 labelfat=3 titlefat=3 titlesz=11
    ''')

Plot('geom/gxgycoord1',
    '''
    graph symbol="+" title="" label1="X" unit1="ft" label2="Y" unit2="ft" plotcol=6 labelsz=0
    min1=7.87573e+05 max1=8.09806e+05 min2=9.3841e+05 max2=9.76868e+05
    ''')

# Create text boxes
Plot('geom/r1',None,'box x0=9.868333 y0=7.230000 label="1" size=.3 xt=+0.5 yt=-0.3')
Plot('geom/r2',None,'box x0=9.868333 y0=7.410000 label="2" size=.3 xt=+0.5 yt=+0.3')
Plot('geom/r3',None,'box x0=9.208333 y0=7.590000 label="3" size=.3 xt=+0.5 yt=+0.3')

# Collect one shot coordinate and its corresponding receiver coordinates and in one plot.
Plot('geom/sxsygxgycoord1','geom/sxsycoord1 geom/gxgycoord1 geom/r1 geom/r2 geom/r3','Overlay')

# Read and write another shot gather.
Flow(['geom/fldr825.rsf','geom/fldr825_hdr.rsf'],
       ['fetch/npr3_field.rsf','fetch/npr3_field_hdr.rsf'],
       '''
         sftahsort
         input=$SOURCE
         sort="fldr:825,825"
         verbose=1
       | sftahwindow ns=2047
       | sftahwrite
          verbose=1
          mode=seq
         output=$TARGET
       ''',stdout=0,stdin=0)

# One shot coordinate.
Flow('geom/sx2','geom/fldr825_hdr.rsf','dd type=float | headermath output="sx"')
Flow('geom/sy2','geom/fldr825_hdr.rsf','dd type=float | headermath output="sy"')
Flow('geom/sxsycoord2',['geom/sx2','geom/sy2'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# Receiver coordinates associated with the single shot.
Flow('geom/gx2','geom/fldr825_hdr.rsf','dd type=float | headermath output="gx"')
Flow('geom/gy2','geom/fldr825_hdr.rsf','dd type=float | headermath output="gy"')
Flow('geom/gxgycoord2',['geom/gx2','geom/gy2'],'cmplx ${SOURCES[1]} | math output="input*0.001"')

# Plot one shot coordinate and its corresponding receiver coordinates.
Plot('geom/sxsycoord2',
    '''
    graph symbol="+" title="(b)" label1="X" unit1="ft" label2="Y" unit2="ft" plotcol=5 plotfat=12 labelsz=11 symbolsz=8
    min1=7.87573e+05 max1=8.09806e+05 min2=9.3841e+05 max2=9.76868e+05 labelfat=3 titlefat=3 titlesz=11
    ''')

Plot('geom/gxgycoord2',
    '''
    graph symbol="+" title="" label1="X" unit1="ft" label2="Y" unit2="ft" plotcol=6 labelsz=0
    min1=7.87573e+05 max1=8.09806e+05 min2=9.3841e+05 max2=9.76868e+05
    ''')

# Collect one shot coordinate and its corresponding receiver coordinates and in one plot.
Plot('geom/sxsygxgycoord2','geom/sxsycoord2 geom/gxgycoord2','Overlay')

Result('geom/sxsygxgycoord12','geom/sxsygxgycoord1 geom/sxsygxgycoord2','SideBySideAniso')

# Read the CMP gathers.
Flow('geom/gathers geom/mask','fetch/npr3_field_cmp.rsf fetch/npr3_field_cmp_hdr.rsf',
     'intbin3 head=${SOURCES[1]} xkey=-1 mask=${TARGETS[1]}')

# Calculate the fold.
Flow('geom/fold','geom/mask','dd type=float | stack axis=1 norm=n')

# Save the plot of the fold map.
Result('geom/fold',
       '''
       grey transp=n yreverse=n allpos=y color=j scalebar=y
       label1="Crossline#" unit1="" label2="Inline#" unit2="" labelsz=5 
       wanttitle=n barlabel="Fold" barunit="" screenratio=1.3 labelfat=2 
       ''')

                       ############################
                       ### Amplitude Correction ###
                       ############################

# Take three shot gathers from fldr214.
Plot('geom/fldr214',
       '''
       window max1=3 min2=440 max2=630 | 
       grey label1=Time unit1=s label2=Trace# unit2="" wanttitle=n pclip=90
       labelsz=6 labelfat=2
       ''')

# Create text boxes.
Plot('ampcor/r1',None,'box x0=4.368333 y0=8.430000 label="1" size=.18 xt=+0.5 yt=+0.3')
Plot('ampcor/r2',None,'box x0=8.288333 y0=8.430000 label="2" size=.18 xt=+0.5 yt=+0.3')
Plot('ampcor/r3',None,'box x0=11.808333 y0=8.430000 label="3" size=.18 xt=+0.5 yt=+0.3')

# Collect the results in one plot.
Result('ampcor/fldr_214','geom/fldr214 ampcor/r1 ampcor/r2 ampcor/r3','Overlay')

# Take a shot gather.
Flow('ampcor/fldr214_subset','geom/fldr214','window max1=2 min2=510 max2=570')

# Apply tpow to the shot gather. 
Flow('ampcor/fldr214_subset_tpow','ampcor/fldr214_subset','pow pow1=2')

# Apply AGC to the shot gather.
Flow('ampcor/fldr214_subset_agc','ampcor/fldr214_subset','agc rect1=500')

# Plot the raw shot gather.
Plot('ampcor/fldr214_subset',
        ''' 
        grey label1=Time unit1=s label2=Trace# unit2= title="(a)" pclip=90
        labelsz=14 labelfat=6 titlesz=16 titlefat=6
        ''')

# Plot the shot gather in (a) with tpow. 
Plot('ampcor/fldr214_subset_tpow',
        '''
          grey label1=Time unit1=s label2=Trace# unit2= title="(b)" pclip=90
          labelsz=14 labelfat=6 titlesz=16 titlefat=6
        ''')

# Plot the shot gather in (a) with AGC.
Plot('ampcor/fldr214_subset_agc',
        '''
          grey label1=Time unit1=s label2=Trace# unit2= title="(c)" pclip=90
          labelsz=14 labelfat=6 titlesz=16 titlefat=6
        ''')

# Collect the results in one plot.
Result('ampcor/fldr214_all','ampcor/fldr214_subset ampcor/fldr214_subset_tpow ampcor/fldr214_subset_agc','SideBySideAniso')

                       ###############################
                       ### Ground Roll Attenuation ###
                       ###############################

# Apply tpow to the shot gather.
Flow('groll/fldr214_subset_tpow','ampcor/fldr214_subset','pow pow1=2.0')

# Plot the shot gather after tpow.
Plot('groll/fldr214_subset_tpow',
        '''
        grey label1=Time unit1=s label2=Trace# unit2= 
        labelsz=14 labelfat=6 titlesz=16 titlefat=6
        title="(a)" pclip=98
        ''')

# Create a text box that highlights the ground roll.
Plot('groll/gr',None,'box x0=6.968333 y0=7.250000 label="ground roll" size=.45 xt=-2.2 yt=+1.5')

# Plot the raw shot gather with the text box.
Plot('groll/fldr214_subset_tpow_gr','groll/fldr214_subset_tpow groll/gr','Overlay')

# LTF transform of the raw shot.
Flow('groll/ltft_214','groll/fldr214_subset_tpow',
     '''
     ltft rect=20 verb=n nw=200 dw=0.5 niter=25
     ''')

# Plot the LTF spectra.
Plot('groll/ltft_214',
       '''
       math output="abs(input)" | real |
       byte allpos=y gainpanel=40 pclip=100 |
       transp plane=23 memsize=1000 |
       grey3 color=j frame1=375 frame2=30 frame3=40 flat=y 
       label1=Time unit1=s label2=Trace# unit2= label3=f unit3=Hz
       title="(a)" point1=0.7 point2=0.6
       labelsz=14 labelfat=6 titlesz=12 titlefat=6 
       ''')

# Apply thresholding to estimate the ground roll energy.
Flow('groll/ltftthr_214','groll/ltft_214',
     '''
     transp plane=23 memsize=1000 |
     threshold2 pclip=25 verb=y |
     transp plane=23 memsize=1000
     ''')

# Plot the thresholded spectra.
Plot('groll/ltftthr_214',
       '''
       math output="abs(input)" | real |
       byte allpos=y gainpanel=40 pclip=100 |
       transp plane=23 memsize=1000 |
       grey3 color=j frame1=375 frame2=30 frame3=40 flat=y
       label1=Time unit1=s label2=Trace# unit2= label3=f unit3=Hz
       title="(b)" point1=0.7 point2=0.6
       labelsz=14 labelfat=6 titlesz=12 titlefat=6
       ''')

# Go back to time domain and apply muting to seperate the ground roll.
Flow('groll/ltftthrinv_214','groll/ltftthr_214',
       '''
       ltft inv=y verb=n |
       mutter t0=0.9 slope0=-0.015 |
       mutter x0=540 slope0=0.015
       ''')

# Plot the estimated ground roll.
Plot('groll/ltftthrinv_214',
        '''
        grey label1=Time unit1=s label2=Trace# unit2=
        labelsz=14 labelfat=6 titlesz=16 titlefat=6
        title="(b)" pclip=98
        ''')

# LTFT of the estimated ground roll.
Flow('groll/ltftthrinvfwd_214','groll/ltftthrinv_214',
     '''
     ltft rect=20 verb=n nw=200 dw=0.5 niter=25
     ''')

# Plot LTFT of the estimated ground roll.
Plot('groll/ltftthrinvfwd_214',
       '''
       math output="abs(input)" | real |
       byte allpos=y gainpanel=40 pclip=100 |
       transp plane=23 memsize=1000 |
       grey3 color=j frame1=375 frame2=30 frame3=40 flat=y
       label1=Time unit1=s label2=Trace# unit2= label3=f unit3=Hz
       title="(b)" point1=0.7 point2=0.6
       labelsz=14 labelfat=6 titlesz=12 titlefat=6
       ''')

# Subtract the estimated ground roll to obtain the signal.
Flow('groll/ltftsig_214','groll/fldr214_subset_tpow groll/ltftthrinv_214',
       '''
       add scale=1,-1 ${SOURCES[1]} |
       mutter t0=0.9 slope0=-0.015  |
       mutter x0=540 slope0=0.015
       ''')

# Plot the signal after ground roll attenuation.
Plot('groll/ltftsig_214',
        '''
        grey label1=Time unit1=s label2=Trace# unit2=
        labelsz=14 labelfat=6 titlesz=16 titlefat=6
        title="(c)" pclip=98
        ''')

# Concatenate the plots.
Result('groll/ltftalltd','groll/fldr214_subset_tpow_gr groll/ltftthrinv_214 groll/ltftsig_214','SideBySideAniso')

# LTFT of the signal.
Flow('groll/ltftsigfwd_214','groll/ltftsig_214',
     '''
     ltft rect=20 verb=n nw=200 dw=0.5 niter=25
     ''')

# Plot LTFT of the signal.
Plot('groll/ltftsigfwd_214',
       '''
       math output="abs(input)" | real |
       byte allpos=y gainpanel=40 pclip=100 |
       transp plane=23 memsize=1000 |
       grey3 color=j frame1=375 frame2=30 frame3=40 flat=y
       label1=Time unit1=s label2=Trace# unit2= label3=f unit3=Hz
       title="(c)" point1=0.7 point2=0.6
       labelsz=14 labelfat=6 titlesz=12 titlefat=6
       ''')

# Concatenate the plots.
Result('groll/ltftallfd','groll/ltft_214 groll/ltftthrinvfwd_214 groll/ltftsigfwd_214','SideBySideAniso')

# Resort the raw shot gathers.
Flow(['fetch/npr3_field_tah.rsf','fetch/npr3_field_tah_hdr.rsf'],
     ['fetch/npr3_field.rsf','fetch/npr3_field_hdr.rsf'],
     '''
       sftahsort verbose=1 input=${SOURCES[0]} sort='fldr tracf' |
       sftahwrite
       verbose=1
       label2="tracf" o2=1 n2=1063 d2=1
       label3="fldr"  o3=14 n3=850 d3=1
       output=${TARGETS[0]}
       outheaders=${TARGETS[1]}
     ''',stdout=0,stdin=0)

# Apply the method to the whole 3D data.

                       #############     !!!CAUTION!!!     ############
                       # It takes around 10 hours to apply the method #
		       # to the whole 3D data on a Mac with 32 GB of  #
		       # memory and a 4 GHz Intel Core i7 processor.  #
                       #############     !!!CAUTION!!!     ############

groundrolls=[]
for i in range(14, 864):
      groundroll='groll/groll-%d' % i
      Flow(groundroll,'fetch/npr3_field_tah.rsf',
               '''
               window n3=1 min3=%d |
               pow pow1=2.0 |
               ltft rect=20 verb=n nw=50 dw=2 niter=25 |
               transp plane=23 memsize=3000 |
               threshold2 pclip=25 verb=y |
               transp plane=23 memsize=3000 |
               ltft inv=y verb=n
               ''' % i)
      groundrolls.append(groundroll)

# Concatenate each shot gather after ground roll estimation.
Flow('groll/npr3_field_tah_groll',groundrolls,'cat ${SOURCES[1:%d]}' % len(groundrolls))

# Delete all the intermediate files.
#Flow('dummy',groundrolls,'rm ${SOURCES[0:%d]}' % len(groundrolls), stdout=-1)

# Substract the estimated ground roll from the raw shot gathers.
Flow('groll/npr3_field_tah_nogroll','fetch/npr3_field_tah groll/npr3_field_tah_groll','pow pow1=2.0 | add scale=1,-1 ${SOURCES[1]}')
Flow('groll/npr3_field_tah_nogroll_hdr','fetch/npr3_field_tah_hdr','cp')

                       #################################
                       ### Deconvolution and Statics ###
                       #################################

              ###############     !!!CAUTION!!!     #############
              # Deconvolution code 'sftahpef' was updated on    #
              # July 17, 2017. If you don't have the updated     #
              # version, it will not work properly when running #
              # it on the whole data set.                       #
              ###############     !!!CAUTION!!!     #############

# Extract a subset of shot gathers for AGC and mute.
Flow(['deconstat/agcmuteshot.rsf','deconstat/agcmuteshot_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=0 input=${SOURCES[0]} sort='fldr:214,214,1 tracf'
     | sftahagc
       wagc=1.000 verbose=1
     | sftahmute
       tmute=0,1.20,1.82 
       xmute=0,8560,18000
       ntaper=80
     | sftahwrite 
        verbose=1                           
        label2="tracf" o2=1 n2=1063 d2=1   
        label3="fldr" o3=214 n3=1 d3=1   
        output=${TARGETS[0]}
        outheaders=${TARGETS[1]} 
     ''',stdout=0,stdin=0)

# Extract a subset of shot gathers for mute, spiking deconvolution and AGC.
Flow(['deconstat/mutepefagcshot.rsf','deconstat/mutepefagcshot_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=0 input=${SOURCES[0]} sort='fldr:214,214,1 tracf'
     | sftahmute 
       tmute=0,1.20,1.82 
       xmute=0,8560,18000 
       ntaper=80 
     | sftahpef 
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3 
     | sftahagc
       wagc=1.000 verbose=1
     | sftahwrite 
        verbose=1                           
        label2="tracf" o2=1 n2=1063 d2=1   
        label3="fldr" o3=214 n3=1 d3=1   
        output=${TARGETS[0]}
        outheaders=${TARGETS[1]}
     ''',stdout=0,stdin=0)

# Extract a subset of shot gathers for mute, spiking deconvolution, AGC, and static corrections.
Flow(['deconstat/mutepefagcstaticshot.rsf','deconstat/mutepefagcstaticshot_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=0 input=${SOURCES[0]} sort='fldr:214,214,1 tracf'
     | sftahmute 
       tmute=0,1.20,1.82 
       xmute=0,8560,18000 
       ntaper=80 
     | sftahpef 
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3 
     | sftahagc
       wagc=1.000 verbose=1 
     | sftahstatic sign=-1 
     | sftahwrite 
        verbose=1                           
        label2="tracf" o2=1 n2=1063 d2=1   
        label3="fldr" o3=214 n3=1 d3=1   
        output=${TARGETS[0]}
        outheaders=${TARGETS[1]} 
     ''',stdout=0,stdin=0)

# Plot the shot gather for shot index 214 after AGC and mute.
Plot('deconstat/agcmuteshotzoom','deconstat/agcmuteshot',
       '''
       sfwindow min1=0 max1=2 min2=510 max2=570 |
       sfgrey label1="Time" unit1="s" label2="Trace#" unit2="" title="(a)"
       pclip=98 transp=y yreverse=y labelsz=14 labelfat=6 titlesz=16 titlefat=6
       ''')

# Plot the shot gather for shot index 214 after mute, spiking deconvolution and AGC.
Plot('deconstat/mutepefagcshotzoom','deconstat/mutepefagcshot',
       '''
       sfwindow min1=0 max1=2 min2=510 max2=570 |
       sfgrey label1="Time" unit1="s" label2="Trace#" unit2="" title="(b)"
       pclip=98 transp=y yreverse=y labelsz=14 labelfat=6 titlesz=16 titlefat=6
       ''')

# Plot the shot gather for shot index 214 after mute, spiking deconvolution, AGC, and static correction.
Plot('deconstat/mutepefagcstaticshotzoom','deconstat/mutepefagcstaticshot',
       '''
       sfwindow min1=0 max1=2 min2=510 max2=570 |
       sfgrey label1="Time" unit1="s" label2="Trace#" unit2="" title="(c)"
       pclip=98 transp=y yreverse=y labelsz=14 labelfat=6 titlesz=16 titlefat=6
       ''')

# Concatenate the plots.
Result('deconstat/agcmutepefstaticshot','deconstat/agcmuteshotzoom deconstat/mutepefagcshotzoom deconstat/mutepefagcstaticshotzoom','SideBySideAniso')

# Inline 225 stacked section after AGC and mute.
Flow(['deconstat/muteagcstack225.rsf','deconstat/muteagcstack225_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=1 input=${SOURCES[0]} sort='iline:225,225 xline offset'
     | sftahwindow ns=2047
     | sftahagc
       wagc=1.000 verbose=1 
     | sftahnmo 
       verbose=1  
       tnmo=0.00,.479,.637,.792,.877,1.009,1.104,1.19458,1.615,3.010 
       vnmo=9132.86,10553.29,10921.60,10791.97,11074.19,11649.54,11807.96,12325.03,14410.47,17216.64 
     | sftahmute
       tmute=0,1.20,1.82
       xmute=0,7358,18000
       ntaper=80
     | sftahstack key=iline,xline verbose=1 ntaper=40
     | sftahwrite 
        verbose=1                           
        label2="xline" o2=1 n2=188 d2=1   
        label3="iline" o3=225 n3=1 d3=1   
        output=${TARGETS[0]}
        outheaders=${TARGETS[1]} 
     ''',stdout=0,stdin=0)

# Plot the inline 225 stacked section after mute, and AGC.
Result('deconstat/muteagcstack225',
       '''
       window min1=0.5 max1=2.0 min2=55 max2=150 |
       wiggle label2="Crossline#" wanttitle=n grid=n 
       transp=y poly=y yreverse=y wherexlabel=t labelsz=6 labelfat=2
       ''')

# Inline 225 stacked section after mute, spiking decon, AGC, and refraction statics.
Flow(['deconstat/mutepefagcstaticstack225.rsf','deconstat/mutepefagcstaticstack225_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=1 input=${SOURCES[0]} sort='iline:225,225 xline offset'
     | sftahwindow ns=2047
     | sftahmute 
       tmute=-.050,-.050,.275,2.0
       xmute=0,880,1760,18000
       ntaper=80 
     | sftahpef 
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3 
     | sftahagc 
       wagc=1.000 verbose=1 
     | sftahstatic sign=-1   
     | sftahnmo 
       verbose=1  
       tnmo=0.00,.479,.637,.792,.877,1.009,1.104,1.19458,1.615,3.010 
       vnmo=9132.86,10553.29,10921.60,10791.97,11074.19,11649.54,11807.96,12325.03,14410.47,17216.64
     | sftahmute 
       tmute=0,1.20,1.82 
       xmute=0,7358,18000 
       ntaper=80 
     | sftahstack key=iline,xline verbose=1 ntaper=40
     | sftahwrite 
        verbose=1                           
        label2="xline" o2=1 n2=188 d2=1   
        label3="iline" o3=225 n3=1 d3=1   
        output=${TARGETS[0]}
        outheaders=${TARGETS[1]} 
     ''',stdout=0,stdin=0)

# Plot the inline 225 stacked section after mute, spiking decon, AGC, and refraction statics.
Result('deconstat/mutepefagcstaticstack225',
       '''
       window min1=0.5 max1=2.0 min2=55 max2=150 |
       wiggle label2="Crossline#" wanttitle=n grid=n
       transp=y poly=y yreverse=y wherexlabel=t labelsz=6 labelfat=2
       ''')

# Sort to CMP domain and apply mute, spiking decon, AGC, and refraction statics to the CMP gathers 
# at which the velocity analysis will be performed.
Flow(['deconstat/npr3_cmp_deconstat.rsf','deconstat/npr3_cmp_deconstat_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort verbose=1 input=${SOURCES[0]} sort='iline:25,337,24 xline:25,169,24 offset'
     | sftahmakeskey pkey=iline,xline skey=cdpt verbose=1
     | sftahmute
       tmute=-.050,-.050,.275,2.0
       xmute=0,880,1760,18000
       ntaper=80
     | sftahpef
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3
     | sftahagc
       wagc=1.000 verbose=1
     | sftahstatic sign=-1
     | sftahmute
       tmute=0,1.20,1.82
       xmute=0,7358,18000
       ntaper=80
     | sftahwrite
       verbose=1
       label2="cdpt"  o2=1  n2=57 d2=1
       label3="xline" o3=25 n3=7  d3=24
       label4="iline" o4=25 n4=14 d4=24
       output=${TARGETS[0]}
       outheaders=${TARGETS[1]}
     ''',stdout=0,stdin=0)

                       #############################################
                       #####   Time-Varying Median Filtering   #####
                       #############################################

# Take a CMP gather from inline=160 xline=120 to illustrate TVMF.
Flow(['tvmf/gather.rsf','tvmf/gather_hdr.rsf','tvmf/gather_nmo.rsf','tvmf/gather_nmo_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf'],
     '''
     sftahsort 
       input=$SOURCE sort='iline:160,160 xline:120,120 offset' 
       verbose=1
     | sftahmakeskey pkey=iline,xline skey=cdpt verbose=1
     | sftahmute
       tmute=0,1.20,1.82
       xmute=0,7358,18000
       ntaper=80
     | sftahpef
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3
     | sftahagc
       wagc=1.000 verbose=1
     | sftahstatic sign=-1
     | sftahwrite
       verbose=1
       label2="cdpt"  o2=1   n2=57 d2=1
       label3="xline" o3=120 n3=1  d3=1
       label4="iline" o4=160 n4=1  d4=1
       output=$TARGET
     | sftahnmo
       verbose=1
       tnmo=0.000,0.653,0.817,0.935,1.036,1.217,1.777,2.000
       vnmo=9026.08,10581.7,10955.5,11225,11572.8,12097,15179.9,15758.0
     | sftahmute
       tmute=0,1.20,1.82
       xmute=0,7358,18000
       ntaper=80
     | sftahwrite 
       verbose=1                           
       label2="cdpt"  o2=1   n2=57 d2=1   
       label3="xline" o3=120 n3=1  d3=1   
       label4="iline" o4=160 n4=1  d4=1   
       output=${TARGETS[2]}
     ''',stdout=0,stdin=0)

# Take offset information of the CMP gather.
Flow('tvmf/offset','tvmf/gather_hdr.rsf','window n1=1 f1=11 | dd type=float')

# Apply TVMF to the CMP gather.
Flow('tvmf/gather_tvmf','tvmf/gather','tvmf nfw=7')

# Calculate the difference.
Flow('tvmf/gather_diff','tvmf/gather tvmf/gather_tvmf','add scale=1,-1 ${SOURCES[1]}')

# Plot the CMP gather before TVMF.
Plot('tvmf/gather','tvmf/gather tvmf/offset',
       '''
       window max1=2.0 max2=25 |
       wiggle xpos=${SOURCES[1]} transp=y poly=y yreverse=y title="(a)"
       label2=Offset unit2=ft wherexlabel=t wheretitle=b grid=n labelsz=14 labelfat=6 titlesz=16 titlefat=6 n1tic=4 o1num=2000 d1num=2000
       ''')

# Plot the CMP gather after TVMF.
Plot('tvmf/gather_tvmf','tvmf/gather_tvmf tvmf/offset',
       '''
       window max1=2.0 max2=25 |
       wiggle xpos=${SOURCES[1]} transp=y poly=y yreverse=y title="(b)"
       label2=Offset unit2=ft wherexlabel=t wheretitle=b grid=n labelsz=14 labelfat=6 titlesz=16 titlefat=6 n1tic=4 o1num=2000 d1num=2000
       ''')

# Plot the difference.
Plot('tvmf/gather_diff','tvmf/gather_diff tvmf/offset',
       '''
       window max1=2.0 max2=25 |
       wiggle xpos=${SOURCES[1]} transp=y poly=y yreverse=y title="(c)"
       label2=Offset unit2=ft wherexlabel=t wheretitle=b grid=n labelsz=14 labelfat=6 titlesz=16 titlefat=6 n1tic=4 o1num=2000 d1num=2000
       ''')

# Concatenate the plots.
Result('tvmf/gather_all','tvmf/gather tvmf/gather_tvmf tvmf/gather_diff','SideBySideAniso')

# Amplitude spectrum of the original trace from the CMP gather.
#Flow('tvmf/gather_spec','tvmf/gather','window n2=1 f2=12 | spectra')
#Plot('tvmf/gather_spec',
#       '''
#       graph parallel2=n n1tic=40 n2tic=20 labelfat=3 title="(a)"
#       gridfat=3 label2=Amplitude label1=Frequency unit2= unit1=Hz wheretitle=t
#       labelsz=10 labelfat=4 titlesz=10 titlefat=4 max1=125 max2=5
#       ''')

# Amplitude spectrum of the trace after TVMF.
#Flow('tvmf/gather_tvmf_spec','tvmf/gather_tvmf','window n2=1 f2=12 | spectra')
#Plot('tvmf/gather_tvmf_spec',
#       '''
#       graph parallel2=n n1tic=40 n2tic=20 labelfat=3 title="(b)"
#       gridfat=3 label2=Amplitude label1=Frequency unit2= unit1=Hz wheretitle=t
#       labelsz=10 labelfat=4 titlesz=10 titlefat=4 max1=125 max2=5
#       ''')

# Amplitude spectrum of the difference.
#Flow('tvmf/gather_diff_spec','tvmf/gather_diff','window n2=1 f2=12 | spectra')
#Plot('tvmf/gather_diff_spec',
#       '''
#       graph parallel2=n n1tic=40 n2tic=20 labelfat=3 title="(c)"
#       gridfat=3 label2=Amplitude label1=Frequency unit2= unit1=Hz wheretitle=t
#       labelsz=10 labelfat=4 titlesz=10 titlefat=4 max1=125 max2=5
#       ''')

# Concatenate the plots.
#Result('tvmf/gather_spec_all','tvmf/gather_spec tvmf/gather_tvmf_spec tvmf/gather_diff_spec','SideBySideIso')

# Apply TVMF to the CMP gathers at which the velocity analysis will be performed.
Flow('tvmf/npr3_cmp_tvmf.rsf','deconstat/npr3_cmp_deconstat.rsf','tvmf nfw=7')

                       #################################
                       #####   Velocity Analysis   #####
                       #################################

# xline points for manual velocity picking.
xl = [25, 25, 49, 49, 49, 49, 73, 73, 73, 73, 73, 73, 73, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 145, 145, 145, 145, 145, 145, 145, 145, 145, 169, 169, 169, 169, 169, 169, 169, 169]

# inline points for manual velocity picking.
il = [289, 265, 313, 289, 265, 241, 337, 313, 289, 265, 241, 217, 193, 313, 289, 265, 241, 193, 217, 169, 145, 121, 97, 289, 265, 241, 217, 193, 169, 145, 121, 97, 73, 49, 217, 193, 169, 145, 121, 97, 73, 49, 25, 193, 169, 145, 121, 97, 73, 49, 25]

# CDP points for manual velocity picking.
cdp = [54169.0, 49657.0, 58705.0, 54193.0, 49681.0, 45169.0, 63241.0, 58729.0, 54217.0, 49705.0, 45193.0, 40681.0, 36169.0, 58753.0, 54241.0, 49729.0, 45217.0, 36192.0, 40705.0, 31681.0, 27169.0, 22657.0, 18145.0, 54265.0, 49753.0, 45241.0, 40729.0, 36217.0, 31705.0, 27193.0, 22681.0, 18169.0, 13657.0, 9145.0, 40753.0, 36241.0, 31729.0, 27217.0, 22705.0, 18193.0, 13681.0, 9169.0, 4657.0, 36265.0, 31753.0, 27241.0, 22729.0, 18217.0, 13705.0, 9193.0, 4681.0]

# Create an ascii file for xline points.
Flow('vel/xl.asc',None,
     'echo 25 25 49 49 49 49 73 73 73 73 73 73 73 97 97 97 97 97 97 97 97 97 97 121 121 121 121 121 121 121 121 121 121 121 145 145 145 145 145 145 145 145 145 169 169 169 169 169 169 169 169 n1=51 n2=1 data_format=ascii_float in=$TARGET')

# Create an ascii file for inline points.
Flow('vel/il.asc',None,
     'echo 289 265 313 289 265 241 337 313 289 265 241 217 193 313 289 265 241 193 217 169 145 121 97 289 265 241 217 193 169 145 121 97 73 49 217 193 169 145 121 97 73 49 25 193 169 145 121 97 73 49 25 n1=51 n2=1 data_format=ascii_float in=$TARGET')

# Read the CDP points from which the RMS velocities are picked.
Flow('vel/xl','vel/xl.asc','echo in=$SOURCE n1=51 n2=1 data_format=ascii_float | dd form=native',stdin=0)
Flow('vel/il','vel/il.asc','echo in=$SOURCE n1=51 n2=1 data_format=ascii_float | dd form=native',stdin=0)
Flow('vel/xlil',['vel/xl','vel/il'],'cmplx ${SOURCES[1]}')

# Plot the CDP points.
Result('vel/xlil',
       '''
       graph symbol="+" title="" label1="Crossline#" unit1="" label2="Inline#" unit2="" plotcol=6 labelsz=5 symbolsz=5
       min1=0 max1=188 d1=1 min2=0 max2=345 d2=1 screenratio=1.5 plotfat=4 labelfat=2
       ''')

                       #######################################################################
                       # If you would like to perform interactive picking, change ipick=True #
                       #######################################################################

ipick=False
if ipick:
  for i in range(len(xl)):

    gather='vel/gather-%d' % i
    gather_hdr='vel/gather-%d_hdr' % i
    offset='vel/offset-%d' % i
    vpicks='vel/vpicks-%d.txt' % i
    
    Flow([gather+".rsf",gather+"_hdr.rsf"],
         ['tvmf/npr3_cmp_tvmf.rsf','deconstat/npr3_cmp_deconstat_hdr.rsf'],
         '''
         sftahsort input=$SOURCE headers=${SOURCES[1]} 
	   sort='iline:%d,%d xline=%d,%d offset'
	 | sftahwrite 
	   mode=seq output=$TARGET 
         '''% (il[i],il[i],xl[i],xl[i]),stdout=0,stdin=0)
    Flow(offset,gather+"_hdr.rsf", 
         'window n1=1 f1=11 | dd type=float')

    Flow(vpicks,[gather, offset],
         '''
         vscan half=n semblance=y v0=9000 nv=101 dv=100 
               offset=${SOURCES[1]} nb=10 |
         ipick grey color=j allpos=y title="Velocity Scan" 
               unit2=ft/s labelsz=5 titlesz=5
         ''')

           ### Illustrate the application of velocity scan and NMO ###

# Plot the windowed CMP gather after tvmf.
Plot('nmostack/gather','tvmf/gather tvmf/offset',
       '''
       tvmf nfw=7 |
       window max1=2.0 max2=25 |
       grey transp=y poly=y yreverse=y title="(a)" label2=Trace# unit2= 
       wherexlabel=t wheretitle=b grid=n labelsz=14 labelfat=6 titlesz=16 titlefat=6
       ''')

# Plot the NMOed CMP gather after tvmf.
Plot('nmostack/gather_nmo','tvmf/gather_nmo tvmf/offset',
       '''
       tvmf nfw=7 |
       window max1=2.0 max2=25 |
       grey transp=y poly=y yreverse=y title="(c)" label2=Trace# unit2= 
       wherexlabel=t wheretitle=b grid=n labelsz=14 labelfat=6 titlesz=16 titlefat=6
       ''')

# Velocity scan.
Flow('nmostack/vscan','tvmf/gather_tvmf tvmf/offset',
       '''
       vscan offset=${SOURCES[1]} v0=9000 nv=101 dv=100 semblance=y half=n nb=16
       ''')

# Plot the windowed velocity scan.
Plot('nmostack/vscan',
       '''
       window max1=2.0 |
       grey color=j allpos=y title="(b)" unit2=ft/s labelsz=14 labelfat=6 titlesz=16 titlefat=6 n1tic=4 o1num=9000 d1num=3000
       ''')

# tnmo and vnmo pairs picked by user.
tnmo=(0.0,0.653913,0.817391,0.935652,1.03652,1.21739,1.77739,2.000)
vnmo=(9026.08,10581.7,10955.5,11225,11572.8,12097,15179.9,15758.0)

# Write user's tnmo and vnmo pairs to a file.
Flow('nmostack/vnmo.asc',None,
     '''
     echo %s n1=%d n2=2 data_format=ascii_float in=$TARGET
     ''' % (' '.join([str(x) for x in tnmo]+[str(x) for x in vnmo]),len(tnmo)))

# Apply a time window to the CMP gather.
Flow('nmostack/gatherwin','tvmf/gather_tvmf','window max1=2.0')

# Interpolate user's tnmo and vnmo pairs.
Flow('nmostack/vnmo','nmostack/vnmo.asc nmostack/gatherwin','dd form=native | linear pattern=${SOURCES[1]} rect=5 niter=100')

# Plot the manually picked RMS velocities for velocity scan.
Plot('nmostack/vnmo',
     '''
     graph yreverse=y transp=y pad=n plotcol=7 plotfat=12 wanttitle=n wherexlabel=t
     label1=Time unit1=s label2='User RMS Velocity' unit2=ft/s labelsz=0 min2=9000 max2=19000
     ''')

# Overlay the plots of velocity scan and user's tnmo-vnmo pairs.
Plot('nmostack/vscanpick','nmostack/vscan nmostack/vnmo','Overlay')

# Collect the plots.
Result('nmostack/gathervscanpicknmo','nmostack/gather nmostack/vscanpick nmostack/gather_nmo','SideBySideAniso')

# Perform interpolation to create 3D volume from manually selected 1D velocity functions.
# If you encounter a problem with the interpolation method (thin_plate) used in interpvel.py, you can try the other methods described in the Python's scipy library.  
# Note that rms_vel.txt and interpvel.py files provided with SConstruct script should be placed in 'vel' directory.

Fetch('rms_vel.txt','teapot')

Flow(['vel/vrms3d','vel/vrms3d.dat'],['rms_vel.txt','interpvel.py'],
     '''
      %s ${SOURCES[1]} 
         nxline=188  fxline=1 
         ninline=345 finline=1
         maxt=4.098  dt=0.002
     '''% sys.executable)

# Plot the 3D RMS velocity model.
#Result('vel/vrms3d',
#     '''
#     transp plane=23 memsize=1000 |
#     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
#     frame1=325 frame2=224 frame3=124 label1=Time unit1=s label2=Inline label3=Crossline labelsz=6
#     scalebar=y barlabel='RMS Velocity' barunit='ft/s' wanttitle=n movie=0 labelfat=2 n2tic=5 o2num=0 d2num=1
#     ''')

# Convert the RMS velocities into interval velocities using Dix equation.
Flow ('vel/vint3d','vel/vrms3d','dix niter=100 rect1=15')

# Plot the 3D interval velocity model.
Result('vel/vint3d',
     '''
     transp plane=23 memsize=1000 |
     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
     frame1=325 frame2=224 frame3=124 label1=Time unit1=s label2=Inline label3=Crossline labelsz=6
     scalebar=y barlabel='Interval Velocity' barunit='ft/s' wanttitle=n movie=0 labelfat=2 n2tic=5 o2num=0 d2num=1
     ''')

# Time to depth conversion.
Flow('vel/vint3dz','vel/vint3d','time2depth dz=30 intime=y nz=1200 velocity=vel/vint3d.rsf')

# Plot the 3D interval velocity model after time to depth conversion.
#Result('vel/vint3dz',
#     '''
#     transp plane=23 memsize=1000 |
#     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
#     frame1=117 frame2=224 frame3=124 label1=Depth unit1=ft label2=Inline label3=Crossline labelsz=6
#     scalebar=y barlabel='Interval Velocity' barunit='ft/s' wanttitle=n movie=0 labelfat=2
#     ''')

# Change the velocity to slowness for migration.
Flow('vel/slo','vel/vint3dz',
     '''
     put d2=110 d3=110 |
     transp plane=12 memsize=1000 | transp plane=23 memsize=1000 |
     math output=1/input
     ''')

# Plot the 3D slowness model in depth.
#Result('vel/slo',
#     '''
#     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
#     frame1=117 frame2=224 frame3=124 label1=Crossline label2=Inline label3=Depth unit3=ft labelsz=6
#     scalebar=y barlabel='Slowness' barunit='s/ft' wanttitle=n movie=0 labelfat=2
#     ''')

                       ########################
                       #####   Stacking   #####
                       ########################

Flow(['nmostack/npr3_stack.rsf','nmostack/npr3_stack_hdr.rsf'],
     ['groll/npr3_field_tah_nogroll.rsf','groll/npr3_field_tah_nogroll_hdr.rsf','vel/vrms3d.rsf'],
     '''
     sftahsort verbose=1 input=${SOURCES[0]} sort='iline xline offset'
     | sftahmute
       tmute=-.050,-.050,.275,2.0
       xmute=0,880,1760,18000
       ntaper=80
     | sftahpef
       verbose=1 minlag=.002 maxlag=.14 pnoise=.01 mincorr=0 maxcorr=3
     | sftahagc
       wagc=1.000 verbose=1
     | sftahstatic sign=-1
     | sftahnmo
       verbose=1
       vfile=${SOURCES[2]}
     | sftahstack key=iline,xline verbose=1 ntaper=40
       tmute=0,1.20,1.82 
       xmute=0,7358,18000 
       ntaper=80
     | sftahwrite
       verbose=1
       label2="xline" o2=1 n2=188 d2=1
       label3="iline" o3=1 n3=345 d3=1
       output=${TARGETS[0]}
       outheaders=${TARGETS[1]}
     ''',stdout=0,stdin=0)

# Plot the 3D stack cube.
Result('nmostack/npr3_stack',
     '''
     bandpass flo=12 fhi=90 |
     shapeagc rect1=100 |
     transp plane=23 memsize=1000 |
     window min1=0.6 max1=1.4 min2=75 max2=250 min3=55 max3=150 |
     byte gainpanel=all pclip=100 | sfgrey3 flat=n point1=0.7 point2=0.7
     frame1=25 frame2=150 frame3=70 label1=Time unit1=s label2=Inline label3=Crossline
     labelsz=6 wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80 d1num=40 n2tic=5 o2num=0.6 d2num=0.2
     ''')

                       #######################
                       ####   Migration   ####
                       #######################

         ##############     !!!CAUTION!!!     ##############
         # It takes around 2.5 hours to run the migration  #
         # on a Mac with 32 GB of memory and a 4 GHz Intel #
         # Core i7 processor.                              #
         ##############     !!!CAUTION!!!     ##############

# Take FFT of the stack.
Flow('mig/fft','nmostack/npr3_stack',
     'put d2=110 d3=110 | fft1 | window max1=50 | transp plane=12 memsize=1000 | transp plane=23 memsize=1000')

# Perform 3D extended split-step Fourier depth migration.
Flow('mig/ssfmig','mig/fft vel/slo',
     '''
     zomig3 ompnth=1 mode=m --readwrite=y verb=y
     nrmax=1 slo=${SOURCES[1]} pmx=30 pmy=30
     ''',split=[3,217],reduce='add')

# Transpose the migration result back to y,x,z.
Flow('mig/ssfmigz','mig/ssfmig',
     '''
     transp plane=23 memsize=1000 | 
     transp plane=12 memsize=1000 |
     put n2=188 d2=1 o2=1 n3=345 d3=1 o3=1 |
     transp plane=23 memsize=1000 |
     put label1="Depth" unit1="ft" label2="Inline" unit2="" label3="Crossline" unit3=""
     ''')

# Plot the depth migration result.
Result('mig/ssfmigz',
       '''
       bandpass flo=12 |
       shapeagc rect1=100 |
       window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
       byte gainpanel=all pclip=100 | grey3 frame1=17 frame2=150 frame3=70 point1=0.7 point2=0.7 flat=n
       label1=Depth unit1=ft label2=Inline unit2= label3=Crossline unit3= title= labelsz=6 movie=0
       wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80 d1num=40 n2tic=4 o2num=3500 d2num=1500
       ''')

# Apply f-x deconvolution as a post migration enhancement tool.
Flow('mig/ssfmigz_fx','mig/ssfmigz',
     '''
     put d1=0.002 |
     fxdecon verb=1 |
     bandpass flo=12 |
     fxdecon verb=1 |
     bandpass flo=12 |
     fxdecon verb=1 |
     bandpass flo=12 |
     put d1=30
     ''')

# Plot the depth migration result after f-x deconvolution.
Result('mig/ssfmigz_fx',
       '''
       shapeagc rect1=100 |
       window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
       byte gainpanel=all pclip=100 | grey3 frame1=17 frame2=150 frame3=70 point1=0.7 point2=0.7 flat=n
       label1=Depth unit1=ft label2=Inline unit2= label3=Crossline unit3= title= labelsz=6 movie=0
       wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80 d1num=40 n2tic=4 o2num=3500 d2num=1500
       ''')

# Estimate the dips of the migrated cube after f-x deconvolution.
Flow('mig/ssfmigz_fx_dip','mig/ssfmigz_fx',
     'dip rect1=10 rect2=10 rect3=10 order=3')

# Local inline dip.
Flow('mig/ssfmigz_fx_dip1','mig/ssfmigz_fx_dip','window n4=1')

# Local crossline dip.
Flow('mig/ssfmigz_fx_dip2','mig/ssfmigz_fx_dip','window f4=1')

# Plot the inline dip cube.
#Result('mig/ssfmigz_fx_dip1',
#     '''
#     window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
#     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
#     frame1=17 frame2=150 frame3=70 label1=Depth unit1=ft label2=Inline label3=Crossline labelsz=6
#     scalebar=y barlabel='Slope' barunit='samples' wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80
#     d1num=40 n2tic=4 o2num=3500 d2num=1500
#     ''')

# Plot the crossline dip cube.
#Result('mig/ssfmigz_fx_dip2',
#     '''
#     window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
#     byte gainpanel=all bar=bar.rsf allpos=n mean=y | sfgrey3 color=j flat=n point1=0.7 point2=0.7
#     frame1=17 frame2=150 frame3=70 label1=Depth unit1=ft label2=Inline label3=Crossline labelsz=6
#     scalebar=y barlabel='Slope' barunit='samples' wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80
#     d1num=40 n2tic=4 o2num=3500 d2num=1500
#     ''')

# Spray
Flow('mig/ssfmigz_fx_spray','mig/ssfmigz_fx mig/ssfmigz_fx_dip',
     'pwspray2 ns2=2 ns3=2 dip=${SOURCES[1]}')

# LUM filtering
Flow('mig/ssfmigz_fx_lum','mig/ssfmigz_fx_spray',
     '''
     transp plane=12 | lum nfw=25 shnclip=13 smnclip=13 boundary=y |
     sfwindow n1=1 f1=13
     ''')

# Plot the depth migration result after LUM filtering.
Result('mig/ssfmigz_fx_lum',
       '''
       shapeagc rect1=100 |
       window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
       byte gainpanel=all pclip=100 | grey3 frame1=17 frame2=150 frame3=70 point1=0.7 point2=0.7 flat=n
       label1=Depth unit1=ft label2=Inline unit2= label3=Crossline unit3= title= labelsz=6 movie=0
       wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80 d1num=40 n2tic=4 o2num=3500 d2num=1500
       ''')

Flow('mig/ssfmigz_fx_lum_diff','mig/ssfmigz_fx mig/ssfmigz_fx_lum','sfadd scale=1,-1 ${SOURCES[1]}')

# Plot the difference after LUM filtering.
#Result('mig/ssfmigz_fx_lum_diff',
#       '''
#       window min1=3000 max1=8500 min2=75 max2=250 min3=55 max3=150 |
#       byte gainpanel=all pclip=100 | grey3 frame1=17 frame2=150 frame3=70 point1=0.7 point2=0.7 flat=n
#       label1=Depth unit1=ft label2=Inline unit2= label3=Crossline unit3= title= labelsz=6 movie=0
#       wanttitle=n movie=0 labelfat=2 n1tic=5 o1num=80 d1num=40 n2tic=4 o2num=3500 d2num=1500
#       ''')

End()
