/* 2-D Low-rank One-step Least Pre-stack Reverse-Time-Migration in the complex domain (both img and data are complex valued)
     img :  crosscorrelation with source normalization (stdout)
*/
/*
  Copyright (C) 2014 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <rsf.h>
#include <mpi.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#ifdef _OPENMP
#include <omp.h>
#endif
#ifdef SF_HAS_FFTW
#include <fftw3.h>
#endif

/*automatically generated headers*/
#include "waveutils.h"
#include "muting.h"

/*******************************************************/
/* main function */
int main(int argc, char* argv[]) 
{
    clock_t tstart,tend;
    double duration;

    /*flags*/
    bool verb, adj; /* migration(adjoint) flag */
    bool wantwf; /* outputs wavefield snapshots */
    bool wantrecord; /* actually means "need record" */
    bool illum; /* source illumination flag*/
    bool roll; /* survey strategy */
    bool stack; /* if y, output stacked image */

    /*I/O*/
    sf_file Fvel;
    sf_file left, right, leftb, rightb;
    sf_file Fsrc, Frcd/*source and record*/;
    sf_file Ftmpwf;
    sf_file Fimg;

    /*axis*/
    sf_axis at, ax, az, as;

    /*geopar variables*/
    int nx, nz;
    int nxb, nzb;
    float dx, dz, ox, oz;
    int spx, spz, gpz, gpx, gpl; /*source/geophone location*/
    int snpint;
    int top, bot, lft, rht; /*abc boundary*/
    int nt;
    float dt;
    float trunc; 

    /*wavefield time axis*/
    int wfnt;
    float wfdt;

    /*misc*/
    int nzx, nx2, nz2, n2, m2, m2b, pad1, nk;
    int ix, iz, it, is;

    /*Propagator*/
    sf_complex **ltf, **rtf;
    sf_complex **ltb, **rtb;

    /*Data*/
    sf_complex ***wvfld;
    sf_complex ***record, **tmprec, **img, **imgsum=NULL, ***imgs=NULL;
    sf_complex ***record2=NULL; /*data sorted for receiver mig*/
    float **sill;

    /*source/shots*/
    sf_complex *ww;
    float *rr;
    int rectz,rectx,repeat; /*refl smoothing parameters*/
    int sht0,shtbgn,shtend,shtnum,shtnum0,shtint,shtcur;

    /*tmp*/
    int tmpint;

    /*parameter structs*/
    geopar geop;
    mpipar mpip;

    /*MPI*/
    int cpuid, numprocs;
    sf_complex *sendbuf, *recvbuf;

    /* receiver migration */
    bool rmig; /* receiver domain migration */
    int rcvint, rcvbgn, rcvend, ir, rcvnum=0, rcvnum0=0;
    sf_file Frcd2;
    bool mute; /*muting in the receiver domain*/
    float vref; /*reference velocity for muting*/
    int wd,depth; /*muting window*/

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &cpuid);
    MPI_Comm_size(MPI_COMM_WORLD, &numprocs);

    sf_init(argc, argv);

    if(cpuid==0) sf_warning("numprocs=%d",numprocs);

    if (!sf_getbool("verb", &verb)) verb=false; /*verbosity*/
    if (!sf_getbool("adj", &adj)) adj=true; /*migration*/
    if (adj)
      if (!sf_getbool("rmig", &rmig)) rmig=false; /*receiver domain migration*/
    if (adj && rmig) {
      if (!sf_getint("rcvint", &rcvint)) rcvint=1;
      if (!sf_getint("rcvbgn", &rcvbgn)) rcvbgn=0;
      if (!sf_getint("rcvend", &rcvend)) rcvend=-1;
    }
    if (!sf_getbool("wantwf", &wantwf)) wantwf=false; /*output forward and backward wavefield*/
    if (!sf_getbool("wantrecord", &wantrecord)) wantrecord=true; /*if n, using record data generated by this program */
    if (!sf_getbool("illum", &illum)) illum=false; /*if n, no source illumination applied */
    if (!sf_getbool("roll", &roll)) roll=false; /*if n, receiver is independent of source location and gpl=nx*/
    if (!sf_getbool("stack", &stack)) stack=true; /*if y, outputs stacked image*/
    /* source/receiver info */
    if (!sf_getint("shtbgn", &shtbgn)) sf_error("Need shot starting location on grid!");
    if (!sf_getint("sht0", &sht0)) sht0=shtbgn; /*actual shot origin on grid*/
    if (!sf_getint("shtend", &shtend)) sf_error("Need shot ending location on grid!");
    if (!sf_getint("shtint", &shtint)) sf_error("Need shot interval on grid!");
    shtnum = (int)((shtend-shtbgn)/shtint) + 1;
    shtnum0 = shtnum;
    if (!sf_getint("spz", &spz)) sf_error("Need source depth!");
    if (!sf_getint("gpz", &gpz)) sf_error("Need receiver depth!");
    if (roll) if (!sf_getint("gpl", &gpl)) sf_error("Need receiver length");
    if (!sf_getint("snapinter", &snpint)) snpint=1;     /* snap interval */
    /*--- parameters of source ---*/
    if (!sf_getfloat("srctrunc", &trunc)) trunc=0.4;
    if (!sf_getint("rectz", &rectz)) rectz=1;
    if (!sf_getint("rectx", &rectx)) rectx=1;
    if (!sf_getint("repeat", &repeat)) repeat=0;
    /* abc parameters */
    if (!sf_getint("top", &top)) top=40;
    if (!sf_getint("bot", &bot)) bot=40;
    if (!sf_getint("lft", &lft)) lft=40;
    if (!sf_getint("rht", &rht)) rht=40;
    if (!sf_getbool("mute", &mute)) mute=false; /*muting in the receiver gather*/
    if (mute) {
      if (!sf_getfloat("vref", &vref)) vref=1500;
      if (!sf_getint("wd", &wd)) wd=5;
      if (!sf_getint("depth", &depth)) depth=gpz; /*muting source depth -> receiver depth according reciprocity*/
    }
    
    /*calculate up shot length*/
    if (shtnum%numprocs!=0) {
      shtnum += numprocs-shtnum%numprocs;
      if (verb && cpuid==0 && !rmig) sf_warning("Total shot number is not divisible by total number of nodes! shunum padded to %d.", shtnum);
    }
    if (adj && rmig) {
      if (rcvend==-1) rcvend=gpl;
      rcvnum = (int)((rcvend-rcvbgn)/rcvint) + 1;
      rcvnum0 = rcvnum;
      if (rcvnum%numprocs!=0) {
	rcvnum += numprocs-rcvnum%numprocs;
	if (verb && cpuid==0) sf_warning("Total receiver number is not divisible by total number of nodes! shunum padded to %d.", rcvnum);
      }
    }

    /*int num_of_shots;
    int *spx, *spz;
    spx = sf_intalloc(num_of_shots);
    spz = sf_intalloc(num_of_shots);
    if ( !sf_getints("spx",spx,num_of_shots) &&
         !sf_getints("spz",spz,num_of_shots) ) sf_error("# of shots mismatch!");
    */

    /*Set I/O file*/
    if (adj) { /* migration */
      if (wantrecord) {
	Frcd = sf_input("input"); /*record from elsewhere*/
	Fsrc  = sf_input("src");   /*source wavelet*/      
      } else {
	Frcd = sf_output("rec"); /*record produced by forward modeling*/
	Fsrc = sf_input("input");   /*source wavelet*/
      }
      Fimg  = sf_output("output");
    } else { /* modeling */
      Fimg = sf_input("input");
      Frcd = sf_output("output");
      Fsrc  = sf_input("src");   /*source wavelet*/      
    }
    left  = sf_input("left");
    right = sf_input("right");
    leftb  = sf_input("leftb");
    rightb = sf_input("rightb");
    Fvel  = sf_input("vel");  /*velocity - just for model dimension*/
    if (wantwf) {
	Ftmpwf  = sf_output("tmpwf");/*wavefield snap*/
    } else {
	Ftmpwf  = NULL;
    }

    /*--- Axes parameters ---*/
    at = sf_iaxa(Fsrc, 1); nt = sf_n(at);  dt = sf_d(at);      
    az = sf_iaxa(Fvel, 1); nzb = sf_n(az); dz = sf_d(az); oz = sf_o(az);
    ax = sf_iaxa(Fvel, 2); nxb = sf_n(ax); dx = sf_d(ax); ox = sf_o(ax);
    nzx = nzb*nxb;
    nz = nzb - top - bot;
    nx = nxb - lft - rht;
    if (!roll) gpl = nx; /* global survey setting */
    /* wavefield axis */
    wfnt = (int)(nt-1)/snpint+1;
    wfdt = dt*snpint;

    /* propagator matrices */
    if (!sf_getint("pad1",&pad1)) pad1=1; /* padding factor on the first axis */
    nz2 = kiss_fft_next_fast_size(nzb*pad1);
    nx2 = kiss_fft_next_fast_size(nxb);
    nk = nz2*nx2; /*wavenumber*/
    if (!sf_histint(left,"n1",&n2) || n2 != nzx) sf_error("Need n1=%d in left",nzx);
    if (!sf_histint(left,"n2",&m2))  sf_error("Need n2= in left");
    if (!sf_histint(right,"n1",&n2) || n2 != m2) sf_error("Need n1=%d in right",m2);
    if (!sf_histint(right,"n2",&n2) || n2 != nk) sf_error("Need n2=%d in right",nk);

    if (!sf_histint(leftb,"n1",&n2) || n2 != nzx) sf_error("Need n1=%d in left",nzx);
    if (!sf_histint(leftb,"n2",&m2b))  sf_error("Need n2= in left");
    if (!sf_histint(rightb,"n1",&n2) || n2 != m2b) sf_error("Need n1=%d in right",m2b);
    if (!sf_histint(rightb,"n2",&n2) || n2 != nk) sf_error("Need n2=%d in right",nk);

    /*check record data*/
    if (adj && wantrecord){
	sf_histint(Frcd,"n1", &tmpint);
	if (tmpint != nt ) sf_error("Error parameter n1 in record!");
	sf_histint(Frcd,"n2", &tmpint);
	if (tmpint != gpl ) sf_error("Error parameter n2 in record!");
	sf_histint(Frcd,"n3", &tmpint);
	if (tmpint != shtnum0 ) sf_error("Error parameter n3 in record!");
    }

    /*allocate memory*/
    ww=sf_complexalloc(nt);
    rr=sf_floatalloc(nzx);
    ltf = sf_complexalloc2(nzx,m2);
    rtf = sf_complexalloc2(m2,nk);
    ltb = sf_complexalloc2(nzx,m2b);
    rtb = sf_complexalloc2(m2b,nk);
    geop = (geopar) sf_alloc(1, sizeof(*geop));
    mpip = (mpipar) sf_alloc(1, sizeof(*mpip));
    tmprec = sf_complexalloc2(nt, gpl);
    if (cpuid==0) {
      record = sf_complexalloc3(nt, gpl, shtnum);
    } else record = NULL;
    wvfld = sf_complexalloc3(nz, nx, wfnt);
    if (illum) sill = sf_floatalloc2(nz, nx);
    else sill = NULL;
    img = sf_complexalloc2(nz, nx);
    if (adj) {
      if (stack) {
	imgsum = sf_complexalloc2(nz, nx);
	imgs = NULL;
#ifdef _OPENMP
#pragma omp parallel for private(ix,iz)
#endif
	for (ix=0; ix<nx; ix++)
	  for (iz=0; iz<nz; iz++)
	    imgsum[ix][iz] = sf_cmplx(0.,0.);
      } else {
	if (cpuid==0) {
	  tmpint = (rmig)? rcvnum:shtnum; /*need to allocate the extra zero-paddings*/
	  imgs = sf_complexalloc3(nz, nx, tmpint);
	  imgsum = NULL;
#ifdef _OPENMP
#pragma omp parallel for default(shared) private(is,ix,iz)
#endif
	  for (is=0; is<tmpint; is++)
	    for (ix=0; ix<nx; ix++)
	      for (iz=0; iz<nz; iz++)
		imgs[is][ix][iz] = sf_cmplx(0.,0.);
	} else imgs = NULL;
      }
    }
    /*read from files*/
    sf_complexread(ww,nt,Fsrc);
    sf_complexread(ltf[0],nzx*m2,left);
    sf_complexread(rtf[0],m2*nk,right);
    sf_complexread(ltb[0],nzx*m2b,leftb);
    sf_complexread(rtb[0],m2b*nk,rightb);
    if(!adj) sf_complexread(img[0],nx*nz,Fimg);
    if (cpuid==0) {
      if(adj && wantrecord) {
	sf_complexread(record[0][0], shtnum0*gpl*nt, Frcd);
	if (shtnum0%numprocs!=0) {
#ifdef _OPENMP
#pragma omp parallel for private(is,ix,it)
#endif
	  for (is=shtnum0; is<shtnum; is++)
	    for (ix=0; ix<gpl; ix++)
	      for (it=0; it<nt; it++)
		record[is][ix][it] = sf_cmplx(0.,0.);
	}
      } else {
#ifdef _OPENMP
#pragma omp parallel for private(is,ix,it)
#endif
	for (is=0; is<shtnum; is++)
	  for (ix=0; ix<gpl; ix++)
	    for (it=0; it<nt; it++)
	      record[is][ix][it] = sf_cmplx(0.,0.);
      }
    }

    if (adj && rmig) {
      if (cpuid==0) {
	record2 = sf_complexalloc3(nt, gpl, rcvnum);
	/*transposing to receiver gather*/
#ifdef _OPENMP
#pragma omp parallel for private(ir,ix,it,iz,is) default(shared)
#endif
	for (ir=0; ir<rcvnum0; ir++) {
	  iz=rcvbgn+ir*rcvint;
	  for (ix=0; ix<gpl; ix++) {
	    if ( ix>=shtbgn && ix<=shtend && (ix-shtbgn)%shtint==0 ) {
	      is = (ix-shtbgn)/shtint;
	      for (it=0; it<nt; it++)
		record2[ir][ix][it] = record[is][iz][it];
	    } else {
	      for (it=0; it<nt; it++)
		record2[ir][ix][it] = sf_cmplx(0,0);
	    }
	  }
	}
	if (mute) {
	  for (ir=0; ir<rcvnum0; ir++)
	    mutingc(nt, gpl, dt, dx, dz, rcvbgn+ir*rcvint, depth, spz, vref, wd, record2[ir]);
	}
	if (rcvnum0%numprocs!=0) {
#ifdef _OPENMP
#pragma omp parallel for private(ir,ix,it)
#endif
	  for (ir=rcvnum0; ir<rcvnum; ir++)
	    for (ix=0; ix<gpl; ix++)
	      for (it=0; it<nt; it++)
		record2[ir][ix][it] = sf_cmplx(0.,0.);
	}
	free(**record); free(*record); free(record);
	record = record2;
      }
    }
    
    /*close RSF files*/
    sf_fileclose(Fsrc);
    sf_fileclose(left);
    sf_fileclose(right);
    sf_fileclose(leftb);
    sf_fileclose(rightb);

    /* output RSF files */

    if (cpuid==0) {
      sf_setn(ax, gpl);
      sf_setn(az, nz);
      as = sf_iaxa(Fvel, 2); /*!!!IMPORTANT!!! CAN I DO BETTER???*/
      sf_setn(as,shtnum0);
      sf_setd(as,shtint*dx);
      sf_seto(as,shtbgn*dx+ox);
      
      if (adj) { /* migration */
	if(!wantrecord) {
	  sf_oaxa(Frcd, at, 1);
	  sf_oaxa(Frcd, ax, 2);
	  sf_oaxa(Frcd, as, 3);
	  sf_settype(Frcd,SF_COMPLEX);	
	}
	sf_setn(ax, nx);
	/*write image*/
	sf_oaxa(Fimg, az, 1);
	sf_oaxa(Fimg, ax, 2);
	if (!stack) { /*output unstacked images*/
	  if (rmig) { /*receiver domain migration*/
	    sf_setn(as,rcvnum0);
	    sf_setd(as,rcvint*dx);
	    sf_seto(as,rcvbgn*dx+ox);
	  }
	  sf_oaxa(Fimg, as, 3);
	}
	sf_settype(Fimg,SF_COMPLEX);
      } else { /* modeling */
	sf_oaxa(Frcd, at, 1);
	sf_oaxa(Frcd, ax, 2);
	sf_oaxa(Frcd, as ,3);
	sf_settype(Frcd,SF_COMPLEX);
      }
      
      if (wantwf) {
	sf_setn(ax, nx);
	/*write temp wavefield */
	sf_setn(at, wfnt);
	sf_setd(at, wfdt);
	
	sf_oaxa(Ftmpwf, az, 1);
	sf_oaxa(Ftmpwf, ax, 2);
	sf_oaxa(Ftmpwf, at, 3);
	sf_settype(Ftmpwf,SF_COMPLEX);
      }

      if (adj && rmig) {
	Frcd2 = sf_output("rec2");
	sf_setn(as,rcvnum0);
	sf_setd(as,rcvint*dx);
	sf_seto(as,rcvbgn*dx+ox);
	sf_oaxa(Frcd2, at, 1);
	sf_oaxa(Frcd2, ax, 2);
	sf_oaxa(Frcd2, as ,3);
	sf_settype(Frcd2,SF_COMPLEX);
	sf_complexwrite(record2[0][0], rcvnum0*gpl*nt, Frcd2);
      }
    }

    MPI_Barrier(MPI_COMM_WORLD);

    /*load constant geopar elements*/
    mpip->cpuid=cpuid;
    mpip->numprocs=numprocs;
    /*load constant geopar elements*/
    geop->nx  = nx;
    geop->nz  = nz;
    geop->nxb = nxb;
    geop->nzb = nzb;
    geop->dx  = dx;
    geop->dz  = dz;
    geop->ox  = ox;
    geop->oz  = oz;
    geop->snpint = snpint;
    geop->spz = spz;
    geop->gpz = gpz;
    geop->gpl = gpl;
    geop->top = top;
    geop->bot = bot;
    geop->lft = lft;
    geop->rht = rht;
    geop->nt = nt;
    geop->dt = dt;
    geop->trunc = trunc;
    geop->adj   = adj;
    geop->verb  = verb;
    geop->illum = illum;
    geop->m2 = m2;
    geop->m2b = m2b;
    geop->pad1 = pad1;
    geop->ltf = ltf;
    geop->rtf = rtf;
    geop->ltb = ltb;
    geop->rtb = rtb;
    geop->ww  = ww;
    geop->rr  = rr;
    geop->mode= 0;

    /********************************/
    tstart = clock();

    if (adj && rmig) { /*reversing shot and receiver*/
      shtnum = rcvnum;
      shtnum0 = rcvnum0;
      shtint = rcvint;
      shtbgn = rcvbgn;
      shtend = rcvend;
      tmpint = gpz;
      gpz = spz;
      spz = tmpint;
    }

    for (is=0; is*numprocs<shtnum; is++){

      shtcur = is*numprocs+cpuid; // current shot index

      if (shtcur<shtnum0) {
	spx = shtbgn + shtint*(shtcur);
	if (roll)
	  gpx = spx - (int)(gpl/2);
	else
	  gpx = 0;
	geop->spx = spx;
	geop->gpx = gpx;
	
	if (verb) {
	  sf_warning("============================");
	  sf_warning("processing shot #%d", shtcur);
	  sf_warning("nx=%d nz=%d nt=%d", geop->nx, geop->nz, geop->nt);
	  sf_warning("nxb=%d nzb=%d ", geop->nxb, geop->nzb);
	  sf_warning("dx=%f dz=%f dt=%f", geop->dx, geop->dz, geop->dt);
	  sf_warning("top=%d bot=%d lft=%d rht=%d", geop->top, geop->bot, geop->lft, geop->rht);
	  sf_warning("rectz=%d rectx=%d repeat=%d srctrunc=%f",rectz,rectx,repeat,geop->trunc);
	  sf_warning("spz=%d spx=%d gpz=%d gpx=%d gpl=%d", spz, spx, gpz, gpx, gpl);
	  sf_warning("snpint=%d wfdt=%f wfnt=%d ", snpint, wfdt, wfnt);
	  sf_warning("sht0=%d shtbgn=%d shtend=%d shtnum0=%d shtnum=%d", sht0, shtbgn, shtend, shtnum0, shtnum);
	  if (roll) sf_warning("Rolling survey!");
	  else sf_warning("Global survey (gpl=nx)!");
	  if (illum) sf_warning("Using source illumination!");
	  else sf_warning("No source illumination!");
	  if (rmig) sf_warning("Receiver domain migration!");
	  if (mute)
	    sf_warning("Receiver gather muting applied: vref=%f wd=%d .",vref,wd);
	  sf_warning("============================");
	}
	
	/*generate reflectivity map*/
	reflgen(nzb, nxb, spz+top, spx+lft, rectz, rectx, repeat, rr);
	
	lrosfor2(wvfld, sill, tmprec, geop);
      }

      if(adj && wantrecord) {
	if (cpuid==0) sendbuf = record[is*numprocs][0];
	else sendbuf = NULL;
	recvbuf = tmprec[0];
	MPI_Scatter(sendbuf, gpl*nt, MPI_COMPLEX, recvbuf, gpl*nt, MPI_COMPLEX, 0, MPI_COMM_WORLD); // tmprec[ix][it] = record[is][ix][it];
      }
      
      if (shtcur<shtnum0) {
	lrosback2(img, wvfld, sill, tmprec, geop);
	if (adj && stack) { /*perform stacking on local node*/
#ifdef _OPENMP
#pragma omp parallel for private(ix,iz)
#endif
	  for (ix=0; ix<nx; ix++) {
	    for (iz=0; iz<nz; iz++) {
#ifdef SF_HAS_COMPLEX_H
	      imgsum[ix][iz] += img[ix][iz];
#else
	      imgsum[ix][iz] = sf_cadd(imgsum[ix][iz],img[ix][iz]);
#endif
	    }
	  }
	}
      }

      if (adj && !stack) {
	/*gather images to master node*/
	if (cpuid==0) recvbuf = imgs[is*numprocs][0];
	else recvbuf = NULL;
	sendbuf = img[0];
	MPI_Gather(sendbuf, nx*nz, MPI_COMPLEX, recvbuf, nx*nz, MPI_COMPLEX, 0, MPI_COMM_WORLD); // imgs[is][ix][iz] = img[ix][iz];
      }

      if (!adj || !wantrecord) {
	if (cpuid==0) recvbuf = record[is*numprocs][0];
	else recvbuf = NULL;
	sendbuf = tmprec[0];
	MPI_Gather(sendbuf, gpl*nt, MPI_COMPLEX, recvbuf, gpl*nt, MPI_COMPLEX, 0, MPI_COMM_WORLD); // record[is][ix][it] = tmprec[ix][it];
      }

      if (wantwf && shtcur==0)
	sf_complexwrite(wvfld[0][0], wfnt*nx*nz, Ftmpwf);
    } /*shot iteration*/

    MPI_Barrier(MPI_COMM_WORLD);
    /*write record/image*/
    if (adj) {
      if (stack) {
	if (cpuid==0) {
#if MPI_VERSION >= 2
	  sendbuf = (sf_complex *) MPI_IN_PLACE;
#else /* will fail */
	  sendbuf = NULL;
#endif 
	  recvbuf = imgsum[0];
	} else {
	  sendbuf = imgsum[0];
	  recvbuf = NULL;
	}
	MPI_Reduce(sendbuf, recvbuf, nx*nz, MPI_COMPLEX, MPI_SUM, 0, MPI_COMM_WORLD); 
	if (cpuid==0)
	  sf_complexwrite(imgsum[0], nx*nz, Fimg);
      } else {
	if (cpuid==0) {
	  tmpint = (rmig)? rcvnum0:shtnum0;
	  sf_complexwrite(imgs[0][0], tmpint*nx*nz, Fimg);
	}
      }
    }

    if (!adj || !wantrecord) {
      if (cpuid==0)
	sf_complexwrite(record[0][0], shtnum0*gpl*nt, Frcd);
    }

    /*free memory*/
    free(ww); free(rr);
    free(*ltf); free(ltf);
    free(*rtf); free(rtf);
    free(*ltb); free(ltb);
    free(*rtb); free(rtb);
    free(geop); free(mpip);
    free(*tmprec); free(tmprec);
    if (cpuid==0) {free(**record); free(*record); free(record);}
    free(**wvfld); free(*wvfld); free(wvfld);
    if (illum) {
      free(*sill); free(sill);
    }
    free(*img); free(img);
    if (adj) {
      if (stack) {
	free(*imgsum); free(imgsum);
      } else {
	if (cpuid==0) {free(**imgs); free(*imgs); free(imgs);}
      }
    }

    tend = clock();
    duration=(double)(tend-tstart)/CLOCKS_PER_SEC;
    sf_warning(">> The CPU time of single shot migration is: %f seconds << ", duration);

    MPI_Finalize();
    exit(0);
}
